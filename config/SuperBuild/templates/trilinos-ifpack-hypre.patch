diff -rupN trilinos-11.0.3-source/packages/ifpack/src/Ifpack_Hypre.cpp trilinos-11.0.3-source-patch/packages/ifpack/src/Ifpack_Hypre.cpp
--- trilinos-11.0.3-source/packages/ifpack/src/Ifpack_Hypre.cpp	2013-09-03 11:45:03.357326012 -0600
+++ trilinos-11.0.3-source-patch/packages/ifpack/src/Ifpack_Hypre.cpp	2013-09-03 11:45:16.140831464 -0600
@@ -68,23 +68,46 @@ Ifpack_Hypre::Ifpack_Hypre(Epetra_RowMat
   MPI_Comm comm = GetMpiComm();
   int ilower = A_->RowMatrixRowMap().MinMyGID();
   int iupper = A_->RowMatrixRowMap().MaxMyGID();
-  // Need to check if the RowMap is the way Hypre expects (if not more difficult)
+  // Need to check if the RowMap is the GID-contiguous, as expected by Hypre
   std::vector<int> ilowers; ilowers.resize(Comm().NumProc());
   std::vector<int> iuppers; iuppers.resize(Comm().NumProc());
   int myLower[1]; myLower[0] = ilower;
   int myUpper[1]; myUpper[0] = iupper;
   Comm().GatherAll(myLower, &ilowers[0], 1);
   Comm().GatherAll(myUpper, &iuppers[0], 1);
+
   for(int i = 0; i < Comm().NumProc()-1; i++){
     NiceRowMap_ = (NiceRowMap_ && iuppers[i]+1 == ilowers[i+1]);
   }
-  if(!NiceRowMap_){
-    ilower = (A_->NumGlobalRows() / Comm().NumProc())*Comm().MyPID();
-    iupper = (A_->NumGlobalRows() / Comm().NumProc())*(Comm().MyPID()+1)-1;
-    if(Comm().MyPID() == Comm().NumProc()-1){
-      iupper = A_-> NumGlobalRows()-1;
-    }
-  }
+
+  if (!NiceRowMap_) {
+    // Must create simple ColumnMap to map indices via LID.
+    //   Epetra_GID  --------->   LID   ----------> HYPRE_GID
+    //           via RowMap.LID()       via SimpleColumnMap.GID()
+    MySimpleMap_ = rcp(new Epetra_Map(-1, A_->RowMatrixRowMap().NumMyElements(),
+            0, Comm()));
+
+    Epetra_Import importer(A_->RowMatrixColMap(), A_->RowMatrixRowMap());
+    Epetra_IntVector MyGIDsHYPRE(A_->RowMatrixRowMap());
+    for (int i=0; i!=A_->RowMatrixRowMap().NumMyElements(); ++i)
+      MyGIDsHYPRE[i] = MySimpleMap_->GID(i);
+
+    // import the HYPRE GIDs
+    Epetra_IntVector ColGIDsHYPRE(A_->RowMatrixColMap());
+    IFPACK_CHK_ERRV(ColGIDsHYPRE.Import(MyGIDsHYPRE, importer, Insert, 0));
+
+    // Make a HYPRE numbering-based column map.
+    MySimpleColumnMap_ = rcp(new Epetra_Map(-1,ColGIDsHYPRE.MyLength(),
+            &ColGIDsHYPRE[0], 0, Comm()));
+
+  } else {
+    MySimpleMap_ = rcp(new Epetra_Map(A_->RowMatrixRowMap()));
+    MySimpleColumnMap_ = rcp(new Epetra_Map(A_->RowMatrixColMap()));
+  }
+
+  // ilower and iupper are now valid for either NiceRowMap_ or not
+  ilower = MySimpleMap_->GID(0);
+  iupper = MySimpleMap_->GID(A_->RowMatrixRowMap().NumMyElements()-1);
 
   // Next create vectors that will be used when ApplyInverse() is called
   IFPACK_CHK_ERRV(HYPRE_IJVectorCreate(comm, ilower, iupper, &XHypre_));
@@ -104,11 +127,6 @@ Ifpack_Hypre::Ifpack_Hypre(Epetra_RowMat
 
   YVec_ = (hypre_ParVector *) hypre_IJVectorObject(((hypre_IJVector *) YHypre_));
   YLocal_ = hypre_ParVectorLocalVector(YVec_);
-  std::vector<int> rows; rows.resize(iupper - ilower +1);
-  for(int i = ilower; i <= iupper; i++){
-    rows[i-ilower] = i;
-  }
-  MySimpleMap_ = rcp(new Epetra_Map(-1, iupper-ilower+1, &rows[0], 0, Comm()));
 } //Constructor
 
 //==============================================================================
@@ -145,10 +163,10 @@ int Ifpack_Hypre::Initialize(){
     int numEntries;
     IFPACK_CHK_ERR(A_->ExtractMyRowCopy(i, numElements, numEntries, &values[0], &indices[0]));
     for(int j = 0; j < numEntries; j++){
-      indices[j] = A_->RowMatrixColMap().GID(indices[j]);
+      indices[j] = MySimpleColumnMap_->GID(indices[j]);
     }
     int GlobalRow[1];
-    GlobalRow[0] = A_->RowMatrixRowMap().GID(i);
+    GlobalRow[0] = MySimpleMap_->GID(i);
     IFPACK_CHK_ERR(HYPRE_IJMatrixSetValues(HypreA_, 1, &numEntries, GlobalRow, &indices[0], &values[0]));
   }
   IFPACK_CHK_ERR(HYPRE_IJMatrixAssemble(HypreA_));
diff -rupN trilinos-11.0.3-source/packages/ifpack/src/Ifpack_Hypre.h trilinos-11.0.3-source-patch/packages/ifpack/src/Ifpack_Hypre.h
--- trilinos-11.0.3-source/packages/ifpack/src/Ifpack_Hypre.h	2013-09-03 11:45:03.753310696 -0600
+++ trilinos-11.0.3-source-patch/packages/ifpack/src/Ifpack_Hypre.h	2013-09-03 11:45:16.508817230 -0600
@@ -648,6 +648,8 @@ private:
   Hypre_Chooser SolveOrPrec_;
   //! This is a linear map used the way it is in Hypre
   Teuchos::RefCountPtr<Epetra_Map> MySimpleMap_;
+  //! This is a linear map used the way it is in Hypre
+  Teuchos::RefCountPtr<Epetra_Map> MySimpleColumnMap_;
   //! Counter of the number of parameters set
   int NumFunsToCall_;
   //! Which solver was chosen
diff -rupN trilinos-11.0.3-source/packages/ifpack/src/tmp/Ifpack_Hypre.cpp trilinos-11.0.3-source-patch/packages/ifpack/src/tmp/Ifpack_Hypre.cpp
--- trilinos-11.0.3-source/packages/ifpack/src/tmp/Ifpack_Hypre.cpp	2013-09-03 11:44:37.854312597 -0600
+++ trilinos-11.0.3-source-patch/packages/ifpack/src/tmp/Ifpack_Hypre.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,615 +0,0 @@
-/*@HEADER
-// ***********************************************************************
-// 
-//       Ifpack: Object-Oriented Algebraic Preconditioner Package
-//                 Copyright (2009) Sandia Corporation
-// 
-// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
-// license for use of this work by or on behalf of the U.S. Government.
-// 
-// This library is free software; you can redistribute it and/or modify
-// it under the terms of the GNU Lesser General Public License as
-// published by the Free Software Foundation; either version 2.1 of the
-// License, or (at your option) any later version.
-//  
-// This library is distributed in the hope that it will be useful, but
-// WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-//  
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
-// USA
-// Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
-// 
-// ***********************************************************************
-//@HEADER
-*/
-#include "Ifpack_Hypre.h"
-#if defined(HAVE_HYPRE) && defined(HAVE_MPI)
-
-#include "Ifpack_Utils.h"
-#include "Epetra_MpiComm.h"
-#include "Epetra_IntVector.h"
-#include "Epetra_Import.h"
-#include "Teuchos_ParameterList.hpp"
-#include "Teuchos_RCP.hpp"
-
-using Teuchos::RCP;
-using Teuchos::rcp;
-
-Ifpack_Hypre::Ifpack_Hypre(Epetra_RowMatrix* A):
-  A_(rcp(A,false)),
-  UseTranspose_(false),
-  IsInitialized_(false),
-  IsComputed_(false),
-  Label_(),
-  NumInitialize_(0),
-  NumCompute_(0),
-  NumApplyInverse_(0),
-  InitializeTime_(0.0),
-  ComputeTime_(0.0),
-  ApplyInverseTime_(0.0),
-  ComputeFlops_(0.0),
-  ApplyInverseFlops_(0.0),
-  Time_(A_->Comm()),
-  SolveOrPrec_(Solver),
-  NumFunsToCall_(0),
-  SolverType_(PCG),
-  PrecondType_(Euclid),
-  UsePreconditioner_(false),
-  NiceRowMap_(true)
-{
-  IsSolverSetup_ = new bool[1];
-  IsPrecondSetup_ = new bool[1];
-  IsSolverSetup_[0] = false;
-  IsPrecondSetup_[0] = false;
-  MPI_Comm comm = GetMpiComm();
-  int ilower = A_->RowMatrixRowMap().MinMyGID();
-  int iupper = A_->RowMatrixRowMap().MaxMyGID();
-  // Need to check if the RowMap is the GID-contiguous, as expected by Hypre
-  std::vector<int> ilowers; ilowers.resize(Comm().NumProc());
-  std::vector<int> iuppers; iuppers.resize(Comm().NumProc());
-  int myLower[1]; myLower[0] = ilower;
-  int myUpper[1]; myUpper[0] = iupper;
-  Comm().GatherAll(myLower, &ilowers[0], 1);
-  Comm().GatherAll(myUpper, &iuppers[0], 1);
-
-  for(int i = 0; i < Comm().NumProc()-1; i++){
-    NiceRowMap_ = (NiceRowMap_ && iuppers[i]+1 == ilowers[i+1]);
-  }
-
-  if (!NiceRowMap_) {
-    // Must create simple ColumnMap to map indices via LID.
-    //   Epetra_GID  --------->   LID   ----------> HYPRE_GID
-    //           via RowMap.LID()       via SimpleColumnMap.GID()
-    MySimpleMap_ = rcp(new Epetra_Map(-1, A_->RowMatrixRowMap().NumMyElements(),
-            0, Comm()));
-
-    Epetra_Import importer(A_->RowMatrixColMap(), A_->RowMatrixRowMap());
-    Epetra_IntVector MyGIDsHYPRE(A_->RowMatrixRowMap());
-    for (int i=0; i!=A_->RowMatrixRowMap().NumMyElements(); ++i)
-      MyGIDsHYPRE[i] = MySimpleMap_->GID(i);
-
-    // import the HYPRE GIDs
-    Epetra_IntVector ColGIDsHYPRE(A_->RowMatrixColMap());
-    IFPACK_CHK_ERRV(ColGIDsHYPRE.Import(MyGIDsHYPRE, importer, Insert, 0));
-
-    // Make a HYPRE numbering-based column map.
-    MySimpleColumnMap_ = rcp(new Epetra_Map(-1,ColGIDsHYPRE.MyLength(),
-            &ColGIDsHYPRE[0], 0, Comm()));
-
-  } else {
-    MySimpleMap_ = rcp(new Epetra_Map(A_->RowMatrixRowMap()));
-    MySimpleColumnMap_ = rcp(new Epetra_Map(A_->RowMatrixColMap()));
-  }
-
-  // ilower and iupper are now valid for either NiceRowMap_ or not
-  ilower = MySimpleMap_->GID(0);
-  iupper = MySimpleMap_->GID(A_->RowMatrixRowMap().NumMyElements()-1);
-
-  // Next create vectors that will be used when ApplyInverse() is called
-  IFPACK_CHK_ERRV(HYPRE_IJVectorCreate(comm, ilower, iupper, &XHypre_));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorSetObjectType(XHypre_, HYPRE_PARCSR));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorInitialize(XHypre_));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorAssemble(XHypre_));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorGetObject(XHypre_, (void**) &ParX_));
-
-  IFPACK_CHK_ERRV(HYPRE_IJVectorCreate(comm, ilower, iupper, &YHypre_));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorSetObjectType(YHypre_, HYPRE_PARCSR));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorInitialize(YHypre_));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorAssemble(YHypre_));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorGetObject(YHypre_, (void**) &ParY_));
-
-  XVec_ = (hypre_ParVector *) hypre_IJVectorObject(((hypre_IJVector *) XHypre_));
-  XLocal_ = hypre_ParVectorLocalVector(XVec_);
-
-  YVec_ = (hypre_ParVector *) hypre_IJVectorObject(((hypre_IJVector *) YHypre_));
-  YLocal_ = hypre_ParVectorLocalVector(YVec_);
-} //Constructor
-
-//==============================================================================
-void Ifpack_Hypre::Destroy(){
-  if(IsInitialized()){
-    IFPACK_CHK_ERRV(HYPRE_IJMatrixDestroy(HypreA_));
-  } 
-  IFPACK_CHK_ERRV(HYPRE_IJVectorDestroy(XHypre_));
-  IFPACK_CHK_ERRV(HYPRE_IJVectorDestroy(YHypre_));
-  if(IsSolverSetup_[0]){
-    IFPACK_CHK_ERRV(SolverDestroyPtr_(Solver_));
-  }
-  if(IsPrecondSetup_[0]){
-    IFPACK_CHK_ERRV(PrecondDestroyPtr_(Preconditioner_));
-  }
-  delete[] IsSolverSetup_;
-  delete[] IsPrecondSetup_;
-} //Destroy()
-
-//==============================================================================
-int Ifpack_Hypre::Initialize(){
-  Time_.ResetStartTime();
-  MPI_Comm comm = GetMpiComm();
-  int ilower = MySimpleMap_->MinMyGID();
-  int iupper = MySimpleMap_->MaxMyGID();
-  IFPACK_CHK_ERR(HYPRE_IJMatrixCreate(comm, ilower, iupper, ilower, iupper, &HypreA_));
-  IFPACK_CHK_ERR(HYPRE_IJMatrixSetObjectType(HypreA_, HYPRE_PARCSR));
-  IFPACK_CHK_ERR(HYPRE_IJMatrixInitialize(HypreA_));
-  for(int i = 0; i < A_->NumMyRows(); i++){
-    int numElements;
-    IFPACK_CHK_ERR(A_->NumMyRowEntries(i,numElements));
-    std::vector<int> indices; indices.resize(numElements);
-    std::vector<double> values; values.resize(numElements);
-    int numEntries;
-    IFPACK_CHK_ERR(A_->ExtractMyRowCopy(i, numElements, numEntries, &values[0], &indices[0]));
-    for(int j = 0; j < numEntries; j++){
-      indices[j] = MySimpleColumnMap_->GID(indices[j]);
-    }
-    int GlobalRow[1];
-    GlobalRow[0] = MySimpleMap_->GID(i);
-    IFPACK_CHK_ERR(HYPRE_IJMatrixSetValues(HypreA_, 1, &numEntries, GlobalRow, &indices[0], &values[0]));
-  }
-  IFPACK_CHK_ERR(HYPRE_IJMatrixAssemble(HypreA_));
-  IFPACK_CHK_ERR(HYPRE_IJMatrixGetObject(HypreA_, (void**)&ParMatrix_));
-  IsInitialized_=true;
-  NumInitialize_ = NumInitialize_ + 1;
-  InitializeTime_ = InitializeTime_ + Time_.ElapsedTime();
-  return 0;
-} //Initialize()
-
-//==============================================================================
-int Ifpack_Hypre::SetParameters(Teuchos::ParameterList& list){
-  List_ = list;
-  Hypre_Solver solType = list.get("Solver", PCG);
-  SolverType_ = solType;
-  Hypre_Solver precType = list.get("Preconditioner", Euclid);
-  PrecondType_ = precType;
-  Hypre_Chooser chooser = list.get("SolveOrPrecondition", Solver);
-  SolveOrPrec_ = chooser;
-  bool SetPrecond = list.get("SetPreconditioner", false);
-  IFPACK_CHK_ERR(SetParameter(SetPrecond));
-  int NumFunctions = list.get("NumFunctions", 0);
-  FunsToCall_.clear();
-  NumFunsToCall_ = 0;
-  if(NumFunctions > 0){
-    RCP<FunctionParameter>* params = list.get<RCP<FunctionParameter>*>("Functions");
-    for(int i = 0; i < NumFunctions; i++){
-      IFPACK_CHK_ERR(AddFunToList(params[i]));
-    }
-  }
-  return 0;
-} //SetParameters()
-
-//==============================================================================
-int Ifpack_Hypre::AddFunToList(RCP<FunctionParameter> NewFun){
-  NumFunsToCall_ = NumFunsToCall_+1;
-  FunsToCall_.resize(NumFunsToCall_);
-  FunsToCall_[NumFunsToCall_-1] = NewFun;
-  return 0;
-} //AddFunToList()
-
-//==============================================================================
-int Ifpack_Hypre::SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, int), int parameter){
-  RCP<FunctionParameter> temp = rcp(new FunctionParameter(chooser, pt2Func, parameter));
-  IFPACK_CHK_ERR(AddFunToList(temp));
-  return 0;
-} //SetParameter() - int function pointer
-
-//==============================================================================
-int Ifpack_Hypre::SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, double), double parameter){
-  RCP<FunctionParameter> temp = rcp(new FunctionParameter(chooser, pt2Func, parameter));
-  IFPACK_CHK_ERR(AddFunToList(temp));
-  return 0;
-} //SetParameter() - double function pointer
-
-//==============================================================================
-int Ifpack_Hypre::SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, double, int), double parameter1, int parameter2){
-  RCP<FunctionParameter> temp = rcp(new FunctionParameter(chooser, pt2Func, parameter1, parameter2));
-  IFPACK_CHK_ERR(AddFunToList(temp));
-  return 0;
-} //SetParameter() - double,int function pointer
-
-//==============================================================================
-int Ifpack_Hypre::SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, int, int), int parameter1, int parameter2){
-  RCP<FunctionParameter> temp = rcp(new FunctionParameter(chooser, pt2Func, parameter1, parameter2));
-  IFPACK_CHK_ERR(AddFunToList(temp));
-  return 0;
-} //SetParameter() int,int function pointer
-
-//==============================================================================
-int Ifpack_Hypre::SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, double*), double* parameter){
-  RCP<FunctionParameter> temp = rcp(new FunctionParameter(chooser, pt2Func, parameter));
-  IFPACK_CHK_ERR(AddFunToList(temp));
-  return 0;
-} //SetParameter() - double* function pointer
-
-//==============================================================================
-int Ifpack_Hypre::SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, int*), int* parameter){
-  RCP<FunctionParameter> temp = rcp(new FunctionParameter(chooser, pt2Func, parameter));
-  IFPACK_CHK_ERR(AddFunToList(temp));
-  return 0;
-} //SetParameter() - int* function pointer
-
-//==============================================================================
-int Ifpack_Hypre::SetParameter(Hypre_Chooser chooser, Hypre_Solver solver){
-  if(chooser == Solver){
-    SolverType_ = solver;
-  } else {
-    PrecondType_ = solver;
-  }
-  return 0;
-} //SetParameter() - set type of solver
-
-//==============================================================================
-int Ifpack_Hypre::Compute(){
-  if(IsInitialized() == false){
-    IFPACK_CHK_ERR(Initialize());
-  }
-  Time_.ResetStartTime();
-  IFPACK_CHK_ERR(SetSolverType(SolverType_));
-  IFPACK_CHK_ERR(SetPrecondType(PrecondType_));
-  CallFunctions();
-  if(UsePreconditioner_){
-    if(SolverPrecondPtr_ != NULL){
-      IFPACK_CHK_ERR(SolverPrecondPtr_(Solver_, PrecondSolvePtr_, PrecondSetupPtr_, Preconditioner_));
-    }
-  }
-  if(SolveOrPrec_ == Solver){
-    IFPACK_CHK_ERR(SolverSetupPtr_(Solver_, ParMatrix_, ParX_, ParY_));
-    IsSolverSetup_[0] = true;
-  } else {
-    IFPACK_CHK_ERR(PrecondSetupPtr_(Preconditioner_, ParMatrix_, ParX_, ParY_));
-    IsPrecondSetup_[0] = true;
-  }
-  IsComputed_ = true;
-  NumCompute_ = NumCompute_ + 1;
-  ComputeTime_ = ComputeTime_ + Time_.ElapsedTime();
-  return 0;
-} //Compute()
-
-//==============================================================================
-int Ifpack_Hypre::CallFunctions() const{
-  for(int i = 0; i < NumFunsToCall_; i++){
-    IFPACK_CHK_ERR(FunsToCall_[i]->CallFunction(Solver_, Preconditioner_));
-  }
-  return 0;
-} //CallFunctions()
-
-//==============================================================================
-int Ifpack_Hypre::ApplyInverse(const Epetra_MultiVector& X, Epetra_MultiVector& Y) const{
-  if(IsComputed() == false){
-    IFPACK_CHK_ERR(-1);
-  }
-  Time_.ResetStartTime();
-  bool SameVectors = false;
-  int NumVectors = X.NumVectors();
-  if (NumVectors != Y.NumVectors()) IFPACK_CHK_ERR(-1);  // X and Y must have same number of vectors
-  if(X.Pointers() == Y.Pointers()){
-    SameVectors = true;
-  }
-  for(int VecNum = 0; VecNum < NumVectors; VecNum++) {
-    //Get values for current vector in multivector.
-    double * XValues;
-    IFPACK_CHK_ERR((*X(VecNum)).ExtractView(&XValues));
-    double * YValues;
-    if(!SameVectors){
-      IFPACK_CHK_ERR((*Y(VecNum)).ExtractView(&YValues));
-    } else {
-      YValues = new double[X.MyLength()];
-    }
-    // Temporarily make a pointer to data in Hypre for end
-    double *XTemp = XLocal_->data;
-    // Replace data in Hypre vectors with epetra values
-    XLocal_->data = XValues;
-    double *YTemp = YLocal_->data;
-    YLocal_->data = YValues;
-
-    IFPACK_CHK_ERR(HYPRE_ParVectorSetConstantValues(ParY_, 0.0));
-    if(SolveOrPrec_ == Solver){
-      // Use the solver methods
-      IFPACK_CHK_ERR(SolverSolvePtr_(Solver_, ParMatrix_, ParX_, ParY_));
-    } else {
-      // Apply the preconditioner
-      IFPACK_CHK_ERR(PrecondSolvePtr_(Preconditioner_, ParMatrix_, ParX_, ParY_));
-    }
-    if(SameVectors){
-      int NumEntries = Y.MyLength();
-      std::vector<double> new_values; new_values.resize(NumEntries);
-      std::vector<int> new_indices; new_indices.resize(NumEntries);
-      for(int i = 0; i < NumEntries; i++){
-        new_values[i] = YValues[i];
-        new_indices[i] = i;
-      }
-      IFPACK_CHK_ERR((*Y(VecNum)).ReplaceMyValues(NumEntries, &new_values[0], &new_indices[0]));
-      delete[] YValues;
-    }
-    XLocal_->data = XTemp;
-    YLocal_->data = YTemp;
-  }
-  NumApplyInverse_ = NumApplyInverse_ + 1;
-  ApplyInverseTime_ = ApplyInverseTime_ + Time_.ElapsedTime();
-  return 0;
-} //ApplyInverse()
-
-//==============================================================================
-int Ifpack_Hypre::Multiply(bool TransA, const Epetra_MultiVector& X, Epetra_MultiVector& Y) const{
-  if(IsInitialized() == false){
-    IFPACK_CHK_ERR(-1);
-  }
-  bool SameVectors = false;
-  int NumVectors = X.NumVectors();
-  if (NumVectors != Y.NumVectors()) IFPACK_CHK_ERR(-1);  // X and Y must have same number of vectors
-  if(X.Pointers() == Y.Pointers()){
-    SameVectors = true;
-  }
-  for(int VecNum = 0; VecNum < NumVectors; VecNum++) {
-    //Get values for current vector in multivector.
-    double * XValues;
-    double * YValues;
-    IFPACK_CHK_ERR((*X(VecNum)).ExtractView(&XValues));
-    double *XTemp = XLocal_->data;
-    double *YTemp = YLocal_->data;
-    if(!SameVectors){
-      IFPACK_CHK_ERR((*Y(VecNum)).ExtractView(&YValues));
-    } else {
-      YValues = new double[X.MyLength()];
-    }
-    YLocal_->data = YValues;
-    IFPACK_CHK_ERR(HYPRE_ParVectorSetConstantValues(ParY_,0.0));
-    // Temporarily make a pointer to data in Hypre for end
-    // Replace data in Hypre vectors with epetra values
-    XLocal_->data = XValues;
-    // Do actual computation.
-    if(TransA) {
-      // Use transpose of A in multiply
-      IFPACK_CHK_ERR(HYPRE_ParCSRMatrixMatvecT(1.0, ParMatrix_, ParX_, 1.0, ParY_));
-    } else {
-      IFPACK_CHK_ERR(HYPRE_ParCSRMatrixMatvec(1.0, ParMatrix_, ParX_, 1.0, ParY_));
-    }
-    if(SameVectors){
-      int NumEntries = Y.MyLength();
-      std::vector<double> new_values; new_values.resize(NumEntries);
-      std::vector<int> new_indices; new_indices.resize(NumEntries);
-      for(int i = 0; i < NumEntries; i++){
-        new_values[i] = YValues[i];
-        new_indices[i] = i;
-      }
-      IFPACK_CHK_ERR((*Y(VecNum)).ReplaceMyValues(NumEntries, &new_values[0], &new_indices[0]));
-      delete[] YValues;
-    }
-    XLocal_->data = XTemp;
-    YLocal_->data = YTemp;
-  }
-  return 0;
-} //Multiply()
-
-//==============================================================================
-ostream& Ifpack_Hypre::Print(ostream& os) const{
-  if (!Comm().MyPID()) {
-    os << endl;
-    os << "================================================================================" << endl;
-    os << "Ifpack_Hypre: " << Label () << endl << endl;
-    os << "Using " << Comm().NumProc() << " processors." << endl;
-    os << "Global number of rows            = " << A_->NumGlobalRows() << endl;
-    os << "Global number of nonzeros        = " << A_->NumGlobalNonzeros() << endl;
-    os << "Condition number estimate = " << Condest() << endl;
-    os << endl;
-    os << "Phase           # calls   Total Time (s)       Total MFlops     MFlops/s" << endl;
-    os << "-----           -------   --------------       ------------     --------" << endl;
-    os << "Initialize()    "   << std::setw(5) << NumInitialize_
-       << "  " << std::setw(15) << InitializeTime_
-       << "              0.0              0.0" << endl;
-    os << "Compute()       "   << std::setw(5) << NumCompute_
-       << "  " << std::setw(15) << ComputeTime_
-       << "  " << std::setw(15) << 1.0e-6 * ComputeFlops_;
-    if (ComputeTime_ != 0.0)
-      os << "  " << std::setw(15) << 1.0e-6 * ComputeFlops_ / ComputeTime_ << endl;
-    else
-      os << "  " << std::setw(15) << 0.0 << endl;
-    os << "ApplyInverse()  "   << std::setw(5) << NumApplyInverse_
-       << "  " << std::setw(15) << ApplyInverseTime_
-       << "  " << std::setw(15) << 1.0e-6 * ApplyInverseFlops_;
-    if (ApplyInverseTime_ != 0.0)
-      os << "  " << std::setw(15) << 1.0e-6 * ApplyInverseFlops_ / ApplyInverseTime_ << endl;
-    else
-      os << "  " << std::setw(15) << 0.0 << endl;
-    os << "================================================================================" << endl;
-    os << endl;
-  }
-  return os;
-} //Print()
-
-//==============================================================================
-double Ifpack_Hypre::Condest(const Ifpack_CondestType CT, 
-                             const int MaxIters,
-                             const double Tol,
-                             Epetra_RowMatrix* Matrix_in){
-  if (!IsComputed()) // cannot compute right now
-    return(-1.0);
-  Condest_ = Ifpack_Condest(*this, CT, MaxIters, Tol, Matrix_in);
-  return(Condest_);
-} //Condest()
-
-//==============================================================================
-int Ifpack_Hypre::SetSolverType(Hypre_Solver Solver){
-  switch(Solver) {
-    case BoomerAMG:
-      if(IsSolverSetup_[0]){
-        SolverDestroyPtr_(Solver_);
-        IsSolverSetup_[0] = false;
-      }
-      SolverCreatePtr_ = &Ifpack_Hypre::Hypre_BoomerAMGCreate;
-      SolverDestroyPtr_ = &HYPRE_BoomerAMGDestroy;
-      SolverSetupPtr_ = &HYPRE_BoomerAMGSetup;
-      SolverPrecondPtr_ = NULL;
-      SolverSolvePtr_ = &HYPRE_BoomerAMGSolve;
-      break;
-    case AMS:
-      if(IsSolverSetup_[0]){
-        SolverDestroyPtr_(Solver_);
-        IsSolverSetup_[0] = false;
-      }
-      SolverCreatePtr_ = &Ifpack_Hypre::Hypre_AMSCreate;
-      SolverDestroyPtr_ = &HYPRE_AMSDestroy;
-      SolverSetupPtr_ = &HYPRE_AMSSetup;
-      SolverSolvePtr_ = &HYPRE_AMSSolve;
-      SolverPrecondPtr_ = NULL;
-      break;
-    case Hybrid:
-      if(IsSolverSetup_[0]){
-        SolverDestroyPtr_(Solver_);
-        IsSolverSetup_[0] = false;
-      }
-      SolverCreatePtr_ = &Ifpack_Hypre::Hypre_ParCSRHybridCreate;
-      SolverDestroyPtr_ = &HYPRE_ParCSRHybridDestroy;
-      SolverSetupPtr_ = &HYPRE_ParCSRHybridSetup;
-      SolverSolvePtr_ = &HYPRE_ParCSRHybridSolve;
-      SolverPrecondPtr_ = &HYPRE_ParCSRHybridSetPrecond;
-      break;
-    case PCG:
-      if(IsSolverSetup_[0]){
-        SolverDestroyPtr_(Solver_);
-        IsSolverSetup_[0] = false;
-      }
-      SolverCreatePtr_ = &Ifpack_Hypre::Hypre_ParCSRPCGCreate;
-      SolverDestroyPtr_ = &HYPRE_ParCSRPCGDestroy;
-      SolverSetupPtr_ = &HYPRE_ParCSRPCGSetup;
-      SolverSolvePtr_ = &HYPRE_ParCSRPCGSolve;
-      SolverPrecondPtr_ = &HYPRE_ParCSRPCGSetPrecond;
-      break;
-    case GMRES:
-      if(IsSolverSetup_[0]){
-        SolverDestroyPtr_(Solver_);
-        IsSolverSetup_[0] = false;
-      }
-      SolverCreatePtr_ = &Ifpack_Hypre::Hypre_ParCSRGMRESCreate;
-      SolverDestroyPtr_ = &HYPRE_ParCSRGMRESDestroy;
-      SolverSetupPtr_ = &HYPRE_ParCSRGMRESSetup;
-      SolverPrecondPtr_ = &HYPRE_ParCSRGMRESSetPrecond;
-      break;
-    case FlexGMRES:
-      if(IsSolverSetup_[0]){
-        SolverDestroyPtr_(Solver_);
-        IsSolverSetup_[0] = false;
-      }
-      SolverCreatePtr_ = &Ifpack_Hypre::Hypre_ParCSRFlexGMRESCreate;
-      SolverDestroyPtr_ = &HYPRE_ParCSRFlexGMRESDestroy;
-      SolverSetupPtr_ = &HYPRE_ParCSRFlexGMRESSetup;
-      SolverSolvePtr_ = &HYPRE_ParCSRFlexGMRESSolve;
-      SolverPrecondPtr_ = &HYPRE_ParCSRFlexGMRESSetPrecond;
-      break;
-    case LGMRES:
-      if(IsSolverSetup_[0]){
-        SolverDestroyPtr_(Solver_);
-        IsSolverSetup_[0] = false;
-      }
-      SolverCreatePtr_ = &Ifpack_Hypre::Hypre_ParCSRLGMRESCreate;
-      SolverDestroyPtr_ = &HYPRE_ParCSRLGMRESDestroy;
-      SolverSetupPtr_ = &HYPRE_ParCSRLGMRESSetup;
-      SolverSolvePtr_ = &HYPRE_ParCSRLGMRESSolve;
-      SolverPrecondPtr_ = &HYPRE_ParCSRLGMRESSetPrecond;
-      break;
-    case BiCGSTAB:
-      if(IsSolverSetup_[0]){
-        SolverDestroyPtr_(Solver_);
-        IsSolverSetup_[0] = false;
-      }
-      SolverCreatePtr_ = &Ifpack_Hypre::Hypre_ParCSRBiCGSTABCreate;
-      SolverDestroyPtr_ = &HYPRE_ParCSRBiCGSTABDestroy;
-      SolverSetupPtr_ = &HYPRE_ParCSRBiCGSTABSetup;
-      SolverSolvePtr_ = &HYPRE_ParCSRBiCGSTABSolve;
-      SolverPrecondPtr_ = &HYPRE_ParCSRBiCGSTABSetPrecond;
-      break;
-    default:
-      return -1;
-    }
-  CreateSolver();
-  return 0;
-} //SetSolverType()
-
-//==============================================================================
-int Ifpack_Hypre::SetPrecondType(Hypre_Solver Precond){
-  switch(Precond) {
-    case BoomerAMG:
-      if(IsPrecondSetup_[0]){
-        PrecondDestroyPtr_(Preconditioner_);
-        IsPrecondSetup_[0] = false;
-      }
-      PrecondCreatePtr_ = &Ifpack_Hypre::Hypre_BoomerAMGCreate;
-      PrecondDestroyPtr_ = &HYPRE_BoomerAMGDestroy;
-      PrecondSetupPtr_ = &HYPRE_BoomerAMGSetup;
-      PrecondSolvePtr_ = &HYPRE_BoomerAMGSolve;
-      break;
-    case ParaSails:
-      if(IsPrecondSetup_[0]){
-        PrecondDestroyPtr_(Preconditioner_);
-        IsPrecondSetup_[0] = false;
-      }
-      PrecondCreatePtr_ = &Ifpack_Hypre::Hypre_ParaSailsCreate;
-      PrecondDestroyPtr_ = &HYPRE_ParaSailsDestroy;
-      PrecondSetupPtr_ = &HYPRE_ParaSailsSetup;
-      PrecondSolvePtr_ = &HYPRE_ParaSailsSolve;
-      break;
-    case Euclid:
-      if(IsPrecondSetup_[0]){
-        PrecondDestroyPtr_(Preconditioner_);
-        IsPrecondSetup_[0] = false;
-      }
-      PrecondCreatePtr_ = &Ifpack_Hypre::Hypre_EuclidCreate;
-      PrecondDestroyPtr_ = &HYPRE_EuclidDestroy;
-      PrecondSetupPtr_ = &HYPRE_EuclidSetup;
-      PrecondSolvePtr_ = &HYPRE_EuclidSolve;
-      break;
-    case AMS:
-      if(IsPrecondSetup_[0]){
-        PrecondDestroyPtr_(Preconditioner_);
-        IsPrecondSetup_[0] = false;
-      }
-      PrecondCreatePtr_ = &Ifpack_Hypre::Hypre_AMSCreate;
-      PrecondDestroyPtr_ = &HYPRE_AMSDestroy;
-      PrecondSetupPtr_ = &HYPRE_AMSSetup;
-      PrecondSolvePtr_ = &HYPRE_AMSSolve;
-      break;
-    default:
-      return -1;
-    }
-  CreatePrecond();
-  return 0;
-
-} //SetPrecondType()
-
-//==============================================================================
-int Ifpack_Hypre::CreateSolver(){
-  MPI_Comm comm;
-  HYPRE_ParCSRMatrixGetComm(ParMatrix_, &comm);
-  return (this->*SolverCreatePtr_)(comm, &Solver_);
-} //CreateSolver()
-
-//==============================================================================
-int Ifpack_Hypre::CreatePrecond(){
-  MPI_Comm comm;
-  HYPRE_ParCSRMatrixGetComm(ParMatrix_, &comm);
-  return (this->*PrecondCreatePtr_)(comm, &Preconditioner_);
-} //CreatePrecond()
-
-#endif // HAVE_HYPRE && HAVE_MPI
diff -rupN trilinos-11.0.3-source/packages/ifpack/src/tmp/Ifpack_Hypre.h trilinos-11.0.3-source-patch/packages/ifpack/src/tmp/Ifpack_Hypre.h
--- trilinos-11.0.3-source/packages/ifpack/src/tmp/Ifpack_Hypre.h	2013-09-03 11:44:37.854312597 -0600
+++ trilinos-11.0.3-source-patch/packages/ifpack/src/tmp/Ifpack_Hypre.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,668 +0,0 @@
-/*@HEADER
-// ***********************************************************************
-// 
-//       Ifpack: Object-Oriented Algebraic Preconditioner Package
-//                 Copyright (2009) Sandia Corporation
-// 
-// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
-// license for use of this work by or on behalf of the U.S. Government.
-// 
-// This library is free software; you can redistribute it and/or modify
-// it under the terms of the GNU Lesser General Public License as
-// published by the Free Software Foundation; either version 2.1 of the
-// License, or (at your option) any later version.
-//  
-// This library is distributed in the hope that it will be useful, but
-// WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-//  
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
-// USA
-// Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
-// 
-// ***********************************************************************
-//@HEADER
-*/
-
-#ifndef IFPACK_HYPRE_H
-#define IFPACK_HYPRE_H
-
-#include "Ifpack_ConfigDefs.h"
-#ifdef HAVE_HYPRE
-
-#include "HYPRE_IJ_mv.h"
-#include "HYPRE_parcsr_ls.h"
-#include "krylov.h"
-#include "_hypre_parcsr_mv.h"
-#include "_hypre_IJ_mv.h"
-#include "HYPRE_parcsr_mv.h"
-#include "HYPRE.h"
-#include "Ifpack_Preconditioner.h"
-#include "Ifpack_Condest.h"
-#include "Ifpack_ScalingType.h"
-#include "Epetra_CompObject.h"
-#include "Epetra_MultiVector.h"
-#include "Epetra_Vector.h"
-#include "Epetra_CrsGraph.h"
-#include "Epetra_CrsMatrix.h"
-#include "Epetra_BlockMap.h"
-#include "Epetra_Map.h"
-#include "Epetra_Object.h"
-#include "Epetra_Comm.h"
-#include "Epetra_CrsMatrix.h"
-#include "Epetra_Time.h"
-#include "Teuchos_RefCountPtr.hpp"
-#include "Epetra_MpiComm.h"
-
-#ifndef HYPRE_ENUMS
-#define HYPRE_ENUMS
-//! This enumerated type defines the allowed solvers and preconditioners in Hypre. Some can be used as both solver and preconditioner.
-enum Hypre_Solver{ 
-    BoomerAMG,
-    ParaSails,
-    Euclid,
-    AMS,
-    Hybrid,
-    PCG,
-    GMRES,
-    FlexGMRES,
-    LGMRES,
-    BiCGSTAB
-};
-
-//! This enumerated type defines the two options for applying inverse, either solve or apply the preconditioner.
-enum Hypre_Chooser{
-    Solver,
-    Preconditioner
-};
-#endif //HYPRE_ENUMS
-
-//! This class is used to help with passing parameters in the SetParameter() function. Use this class to call Hypre's internal parameters.
-class FunctionParameter{
-  public:
-    //! Single int constructor.
-    FunctionParameter(Hypre_Chooser chooser, int (*funct_name)(HYPRE_Solver, int), int param1) :
-      chooser_(chooser),
-      option_(0),
-      int_func_(funct_name),
-      int_param1_(param1) {}
-
-    //! Single double constructor.
-    FunctionParameter(Hypre_Chooser chooser, int (*funct_name)(HYPRE_Solver, double), double param1):
-      chooser_(chooser),
-      option_(1),
-      double_func_(funct_name),
-      double_param1_(param1) {}
-
-    //! Single double, single int constructor.
-    FunctionParameter(Hypre_Chooser chooser, int (*funct_name)(HYPRE_Solver, double, int), double param1, int param2):
-      chooser_(chooser),
-      option_(2),
-      double_int_func_(funct_name),
-      int_param1_(param2),
-      double_param1_(param1) {}
-
-    //! Two ints constructor.
-    FunctionParameter(Hypre_Chooser chooser, int (*funct_name)(HYPRE_Solver, int, int), int param1, int param2):
-      chooser_(chooser),
-      option_(3),
-      int_int_func_(funct_name),
-      int_param1_(param1),
-      int_param2_(param2) {}
-
-    //! Int pointer constructor.
-    FunctionParameter(Hypre_Chooser chooser, int (*funct_name)(HYPRE_Solver, int*), int *param1):
-      chooser_(chooser),
-      option_(4),
-      int_star_func_(funct_name),
-      int_star_param_(param1) {}
-
-    //! Double pointer constructor.
-    FunctionParameter(Hypre_Chooser chooser, int (*funct_name)(HYPRE_Solver, double*), double* param1):
-      chooser_(chooser),
-      option_(5),
-      double_star_func_(funct_name),
-      double_star_param_(param1) {}
-
-    //! Only method of this class. Calls the function pointer with the passed in HYPRE_Solver
-    int CallFunction(HYPRE_Solver solver, HYPRE_Solver precond){
-      if(chooser_ == Solver){
-        if(option_ == 0){
-          return int_func_(solver, int_param1_);
-        } else if(option_ == 1){
-          return double_func_(solver, double_param1_);
-        } else if(option_ == 2){
-          return double_int_func_(solver, double_param1_, int_param1_);
-        } else if (option_ == 3){
-          return int_int_func_(solver, int_param1_, int_param2_);
-        } else if (option_ == 4){
-          return int_star_func_(solver, int_star_param_);
-        } else {
-          return double_star_func_(solver, double_star_param_);
-        }
-      } else {
-        if(option_ == 0){
-          return int_func_(precond, int_param1_);
-        } else if(option_ == 1){
-          return double_func_(precond, double_param1_);
-        } else if(option_ == 2){
-          return double_int_func_(precond, double_param1_, int_param1_);
-        } else if(option_ == 3) {
-          return int_int_func_(precond, int_param1_, int_param2_);
-        } else if(option_ == 4) {
-          return int_star_func_(precond, int_star_param_);
-        } else {
-          return double_star_func_(precond, double_star_param_);
-        }
-      }
-    }
-
-  private:
-    Hypre_Chooser chooser_;
-    int option_;
-    int (*int_func_)(HYPRE_Solver, int);
-    int (*double_func_)(HYPRE_Solver, double);
-    int (*double_int_func_)(HYPRE_Solver, double, int);
-    int (*int_int_func_)(HYPRE_Solver, int, int);
-    int (*int_star_func_)(HYPRE_Solver, int*);
-    int (*double_star_func_)(HYPRE_Solver, double*);
-    int int_param1_;
-    int int_param2_;
-    double double_param1_;
-    int *int_star_param_;
-    double *double_star_param_;
-};
-
-namespace Teuchos {
-  class ParameterList;
-}
-
-//! Ifpack_Hypre: A class for constructing and using an ILU factorization of a given Epetra_RowMatrix, using the Hypre library by Lawrence Livermore National Laboratories.
-
-/*!
-Class Ifpack_Hypre: A class for using methods of Hypre with Epetra objects.
-*/
-
-class Ifpack_Hypre: public Ifpack_Preconditioner {
-      
-public:
-  // @{ Constructors and destructors.
-  //! Constructor
-  Ifpack_Hypre(Epetra_RowMatrix* A);
-  
-  //! Destructor
-  ~Ifpack_Hypre(){ Destroy();}
-
-  // @}
-  // @{ Construction methods
-  
-  //! Initialize the preconditioner, does not touch matrix values.
-  int Initialize();
-  
-  //! Returns \c true if the preconditioner has been successfully initialized.
-  bool IsInitialized() const{ return(IsInitialized_);}
-
-  //! Compute ILU factors L and U using the specified graph, diagonal perturbation thresholds and relaxation parameters.
-  /*! This function computes the ILU(k) factors.
-   */
-  int Compute();
-
-  //! If factor is completed, this query returns true, otherwise it returns false.
-  bool IsComputed() const{ return(IsComputed_);}
-
-
-  //! Set parameters using a Teuchos::ParameterList object.
-  /* This method is only available if the Teuchos package is enabled.
-     This method recognizes six parameter names: Solver,
-     Preconditioner, SolveOrPrecondition, SetPreconditioner, NumFunctions and Functions. These names are
-     case sensitive. Solver requires an enumerated parameter of type Hypre_Solver. Preconditioner is similar
-     except requires the type be a preconditioner. The options are listed below:
-                       Solvers                            Preconditioners
-                       BoomerAMG                          BoomerAMG
-                       AMS                                ParaSails
-                       Hybrid                             AMS
-                       PCG (Default)                      Euclid (Default)
-                       GMRES                              
-                       FlexGMRES                          
-                       LGMRES
-                       BiCGSTAB
-     SolveOrPrecondition takes enumerated type Hypre_Chooser, Solver will solve the system, Preconditioner will apply the preconditioner.
-     SetPreconditioner takes a boolean, true means the solver will use the preconditioner.
-     NumFunctions takes an int that describes how many parameters will be passed into Functions. (This needs to be correct.)
-     Functions takes an array of Ref Counted Pointers to an object called FunctionParameter. This class is implemented in Ifpack_Hypre.h.
-     The object takes whether it is Solver or Preconditioner that we are setting a parameter for.
-     The function in Hypre that sets the parameter, and the parameters for that function. An example is below:
-  
-     RCP<FunctionParameter> functs[2];
-     functs[0] = rcp(new FunctionParameter(Solver, &HYPRE_PCGSetMaxIter, 1000)); // max iterations 
-     functs[1] = rcp(new FunctionParameter(Solver, &HYPRE_PCGSetTol, 1e-7)); // conv. tolerance 
-     list.set("NumFunctions", 2);
-     list.set<RCP<FunctionParameter>*>("Functions", functs); 
-     NOTE: SetParameters() must be called to use ApplyInverse(), the solvers will not be created otherwise. An empty list is acceptable to use defaults.
-  */
-  int SetParameters(Teuchos::ParameterList& parameterlist);
-
-    //! Set a parameter that takes a single int.
-    /*!
-    \param chooser (In) -A Hypre_Chooser enumerated type set to Solver or Preconditioner, whatever the parameter is setting for.
-    \param *pt2Func (In) -The function that sets the parameter. It must set parameters for the type of solver or preconditioner that was created.
-      An example is if the solver is BoomerAMG, the function to set maximum iterations would be &HYPRE_BoomerAMGSetMaxIter
-    \param parameter (In) -The integer parameter being set.
-
-    \return Integer error code, set to 0 if successful.
-   */
-    int SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, int), int parameter);
-
-    //! Set a parameter that takes a single double.
-    /*!
-    \param chooser (In) -A Hypre_Chooser enumerated type set to Solver or Preconditioner, whatever the parameter is setting for.
-    \param *pt2Func (In) -The function that sets the parameter. It must set parameters for the type of solver or preconditioner that was created.
-      An example is if the solver is BoomerAMG, the function to set tolerance would be &HYPRE_BoomerAMGSetTol
-    \param parameter (In) -The double parameter being set.
-
-    \return Integer error code, set to 0 if successful.
-   */
-    int SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, double), double parameter);
-
-    //! Set a parameter that takes a double then an int.
-    /*!
-    \param chooser (In) -A Hypre_Chooser enumerated type set to Solver or Preconditioner, whatever the parameter is setting for.
-    \param *pt2Func (In) -The function that sets the parameter. It must set parameters for the type of solver or preconditioner that was created.
-      An example is if the solver is BoomerAMG, the function to set relaxation weight for a given level would be &HYPRE_BoomerAMGSetLevelRelaxWt
-    \param parameter1 (In) -The double parameter being set.
-    \param parameter2 (In) - The integer parameter being set.
-
-    \return Integer error code, set to 0 if successful.
-   */
-    int SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, double, int), double parameter1, int parameter2);
-
-    //! Set a parameter that takes two int parameters.
-    /*!
-    \param chooser (In) -A Hypre_Chooser enumerated type set to Solver or Preconditioner, whatever the parameter is setting for.
-    \param *pt2Func (In) -The function that sets the parameter. It must set parameters for the type of solver or preconditioner that was created.
-      An example is if the solver is BoomerAMG, the function to set relaxation type for a given level would be &HYPRE_BoomerAMGSetCycleRelaxType
-    \param parameter1 (In) -The first integer parameter being set.
-    \param parameter2 (In) - The second integer parameter being set.
-
-    \return Integer error code, set to 0 if successful.
-   */
-    int SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, int, int), int parameter1, int parameter2);
-
-    //! Set a parameter that takes a double*.
-    /*!
-    \param chooser (In) -A Hypre_Chooser enumerated type set to Solver or Preconditioner, whatever the parameter is setting for.
-    \param *pt2Func (In) -The function that sets the parameter. It must set parameters for the type of solver or preconditioner that was created.
-      An example is if the solver is BoomerAMG, the function to set relaxation weight would be &HYPRE_BoomerAMGSetRelaxWeight
-    \param parameter (In) -The double* parameter being set.
-
-    \return Integer error code, set to 0 if successful.
-   */
-    int SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, double*), double* parameter);
-
-    //! Set a parameter that takes an int*.
-    /*!
-    \param chooser (In) -A Hypre_Chooser enumerated type set to Solver or Preconditioner, whatever the parameter is setting for.
-    \param *pt2Func (In) -The function that sets the parameter. It must set parameters for the type of solver or preconditioner that was created.
-      An example is if the solver is BoomerAMG, the function to set grid relax type would be &HYPRE_BoomerAMGSetGridRelaxType
-    \param parameter (In) -The int* parameter being set.
-
-    \return Integer error code, set to 0 if successful.
-   */
-    int SetParameter(Hypre_Chooser chooser, int (*pt2Func)(HYPRE_Solver, int*), int* parameter);
-
-    //! Sets the solver that is used by the Solve() and ApplyInverse() methods. Until this is called, the default solver is PCG.
-    /*!
-    \param chooser (In) - A Hypre_Chooser enumerated type. If Solver, then we are selecting which solver, if Preconditioner, we are choosing which preconditioner to use.
-    \param Solver (In) -A Hypre_Solver enumerated type to select the solver or preconditioner. Options for solver are:
-    BoomerAMG, AMS, Hybrid, PCG, GMRES, FlexGMRES, LGMRES, and BiCGSTAB. See Hypre Ref Manual for more info on the solvers.
-    Options for Preconditioner are: BoomerAMG, ParaSails, Euclid, and AMS.
-
-    \return Integer error code, set to 0 if successful.
-  */
-
-    int SetParameter(Hypre_Chooser chooser, Hypre_Solver Solver);
-
-    //! Sets the solver to use the selected preconditioner.
-    /*!
-    \param UsePreconditioner (In) -A boolean, true use preconditioner, false do not use the supplied preconditioner with the solver.
-    The solver and preconditioner must have been selected and the solver must be one of the following solvers:
-      Hybrid, PCG, GMRES, FlexGMRES, LGMRES, BiCGSTAB.
-
-    \return Integer error code, set to 0 if successful.
-  */
-
-    int SetParameter(bool UsePreconditioner){ UsePreconditioner = UsePreconditioner_; return 0;}
-
-    //! Choose to solve the problem or apply the preconditioner.
-    /*!
-    \param chooser (In) -A Hypre_Chooser enumerated type, either Solver or Preconditioner.
-    The chosen type must have been selected before this method is called.
-
-    \return Integer error code, set to 0 if successful.
-  */
-    int SetParameter(Hypre_Chooser chooser) { SolveOrPrec_ = chooser; return 0;}
-
-  //! Call all the function pointers stored in this object.
-    int CallFunctions() const;
-
-  //! If set true, transpose of this operator will be applied.
-  /*! This flag allows the transpose of the given operator to be used implicitly.  Setting this flag
-      affects only the Apply() and ApplyInverse() methods.  If the implementation of this interface 
-      does not support transpose use, this method should return a value of -1.
-      
-      \param
-       UseTranspose_in - (In) If true, multiply by the transpose of operator, otherwise just use operator.
-
-      \return Always returns 0.
-  */
-  int SetUseTranspose(bool UseTranspose_in) {UseTranspose_ = UseTranspose_in; return(0);};
-
-  // @}
-
-  // @{ Mathematical functions.
-  // Applies the matrix to X, returns the result in Y.
-  int Apply(const Epetra_MultiVector& X, 
-	       Epetra_MultiVector& Y) const{ return(Multiply(false,X,Y));}
-
-  //! Returns the result of a Epetra_Operator multiplied with an Epetra_MultiVector X in Y.
-  /*! In this implementation, we use the Hypre matrix to multiply with so that the map is the same
-      as what is expected in solving methods. 
-
-    \param 
-    trans - (In) If true, use the transpose operation.
-	   X - (In) A Epetra_MultiVector of dimension NumVectors to mulitply with.
-    \param Out
-	   Y - (Out) A Epetra_MultiVector of dimension NumVectors containing result.
-
-    \return Integer error code, set to 0 if successful.
-  */
-  int Multiply(bool Trans, const Epetra_MultiVector& X, Epetra_MultiVector& Y) const;
-
-  //! Returns the result of a Epetra_Operator inverse applied to an Epetra_MultiVector X in Y.
-  /*! In this implementation, we use several existing attributes to determine how virtual
-      method ApplyInverse() should call the concrete method Solve().  We pass in the UpperTriangular(), 
-      the Epetra_CrsMatrix::UseTranspose(), and NoDiagonal() methods. The most notable warning is that
-      if a matrix has no diagonal values we assume that there is an implicit unit diagonal that should
-      be accounted for when doing a triangular solve.
-
-    \param 
-	   X - (In) A Epetra_MultiVector of dimension NumVectors to solve for.
-    \param Out
-	   Y - (Out) A Epetra_MultiVector of dimension NumVectors containing result.
-
-    \return Integer error code, set to 0 if successful.
-  */
-  int ApplyInverse(const Epetra_MultiVector& X, Epetra_MultiVector& Y) const;
-
-  //! Computes the estimated condition number and returns the value.
-  double Condest(const Ifpack_CondestType CT = Ifpack_Cheap, 
-                 const int MaxIters = 1550,
-                 const double Tol = 1e-9,
-		 Epetra_RowMatrix* Matrix_in = 0);
-
-  //! Returns the computed estimated condition number, or -1.0 if not computed.
-  double Condest() const{ return(Condest_);}
-
-  // @}
-  // @{ Query methods
-  
-  //! Returns a character string describing the operator
-  const char* Label() const {return(Label_);}
-
-  //! Sets label for \c this object.
-  int SetLabel(const char* Label_in)
-  {
-    strcpy(Label_,Label_in);
-    return(0);
-  }
-
-  //! Returns a reference to the map that should be used for domain.
-  const Epetra_Map& OperatorDomainMap() const{ return *MySimpleMap_;}
-
-  //! Returns a reference to the map that should be used for range.
-  const Epetra_Map& OperatorRangeMap() const{ return *MySimpleMap_;}
-  
-  //! Returns 0.0 because this class cannot compute Inf-norm.
-  double NormInf() const {return(0.0);};
-
-  //! Returns false because this class cannot compute an Inf-norm.
-  bool HasNormInf() const {return(false);};
-
-  //! Returns the current UseTranspose setting.
-  bool UseTranspose() const {return(UseTranspose_);};
-
-  //! Returns the Epetra_BlockMap object associated with the range of this matrix operator.
-  const Epetra_Comm & Comm() const{return(A_->Comm());};
-
-  //! Returns a reference to the matrix to be preconditioned.
-  const Epetra_RowMatrix& Matrix() const{ return(*A_);}
-
-  //! Returns the Hypre matrix that was created upon construction. 
-  const HYPRE_IJMatrix& HypreMatrix()
-  {
-    if(IsInitialized() == false)
-      Initialize();
-    return(HypreA_);
-  }
-
-  //! Prints on stream basic information about \c this object.
-  virtual ostream& Print(ostream& os) const;
-
-  //! Returns the number of calls to Initialize().
-  virtual int NumInitialize() const{ return(NumInitialize_);}
-
-  //! Returns the number of calls to Compute().
-  virtual int NumCompute() const{ return(NumCompute_);}
-
-  //! Returns the number of calls to ApplyInverse().
-  virtual int NumApplyInverse() const{ return(NumApplyInverse_);}
-
-  //! Returns the time spent in Initialize().
-  virtual double InitializeTime() const{ return(InitializeTime_);}
-
-  //! Returns the time spent in Compute().
-  virtual double ComputeTime() const{ return(ComputeTime_);}
-
-  //! Returns the time spent in ApplyInverse().
-  virtual double ApplyInverseTime() const{ return(ApplyInverseTime_);}
-
-  //! Returns the number of flops in the initialization phase.
-  virtual double InitializeFlops() const{ return(0.0);}
-
-  //! Returns the number of flops in the compute phase.
-  virtual double ComputeFlops() const{ return(ComputeFlops_);}
-
-  //! Returns the number of flops in the apply inverse phase.
-  virtual double ApplyInverseFlops() const{ return(ApplyInverseFlops_);}
-
-private:
-
-  // @}
-  // @{ Private methods
-
-  //! Copy constructor (should never be used)
-  Ifpack_Hypre(const Ifpack_Hypre& RHS) : Time_(RHS.Comm()){}
-
-  //! operator= (should never be used)
-  Ifpack_Hypre& operator=(const Ifpack_Hypre& RHS){ return(*this);}
-
-  //! Destroys all internal data
-  void Destroy();
-
-  //! Returns the MPI communicator used in the Epetra matrix
-  MPI_Comm GetMpiComm() const
-    { return (dynamic_cast<const Epetra_MpiComm*>(&A_->Comm()))->GetMpiComm();}
-
-  //! Returns the result of a Ifpack_ILU forward/back solve on a Epetra_MultiVector X in Y.
-  /*! 
-    \param In
-    Trans -If true, solve transpose problem.
-    \param 
-    X - (In) A Epetra_MultiVector of dimension NumVectors to solve for.
-    \param Out
-    Y - (Out) A Epetra_MultiVector of dimension NumVectorscontaining result.
-    
-    \return Integer error code, set to 0 if successful.
-  */
-  int Solve(bool Trans, const Epetra_MultiVector& X, Epetra_MultiVector& Y) const;
-
-
-  //! Returns the number of global matrix rows.
-  int NumGlobalRows() const {return(A_->NumGlobalRows());};
-  
-  //! Returns the number of global matrix columns.
-  int NumGlobalCols() const {return(A_->NumGlobalCols());};
-  
-  //! Returns the number of local matrix rows.
-  int NumMyRows() const {return(A_->NumMyRows());};
-  
-  //! Returns the number of local matrix columns.
-  int NumMyCols() const {return(A_->NumMyCols());};
-  
-  //! Sets the solver type to be the passed in solver type.
-  int SetSolverType(Hypre_Solver solver); 
-
-  //! Sets the preconditioner type to be the passed in type.
-  int SetPrecondType(Hypre_Solver precond);
-
-  //! Create the solver.
-  int CreateSolver();
-
-  //! Create the Preconditioner.
-  int CreatePrecond();
-
-  //! Add a function to be called in Compute()
-  int AddFunToList(Teuchos::RCP<FunctionParameter> NewFun);
-
-  //! Create a BoomerAMG solver.
-  int Hypre_BoomerAMGCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_BoomerAMGCreate(solver);}
-
-  //! Create a ParaSails solver.
-  int Hypre_ParaSailsCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_ParaSailsCreate(comm, solver);}
-
-  //! Create a Euclid solver.
-  int Hypre_EuclidCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_EuclidCreate(comm, solver);}
-
-  //! Create an AMS solver.
-  int Hypre_AMSCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_AMSCreate(solver);}
-
-  //! Create a Hybrid solver.
-  int Hypre_ParCSRHybridCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_ParCSRHybridCreate(solver);}
-
-  //! Create a PCG solver.
-  int Hypre_ParCSRPCGCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_ParCSRPCGCreate(comm, solver);}
-
-  //! Create a GMRES solver.
-  int Hypre_ParCSRGMRESCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_ParCSRGMRESCreate(comm, solver);}
-
-  //! Create a FlexGMRES solver.
-  int Hypre_ParCSRFlexGMRESCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_ParCSRFlexGMRESCreate(comm, solver);}
-
-  //! Create a LGMRES solver.
-  int Hypre_ParCSRLGMRESCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_ParCSRLGMRESCreate(comm, solver);}
-
-  //! Create a BiCGSTAB solver.
-  int Hypre_ParCSRBiCGSTABCreate(MPI_Comm comm, HYPRE_Solver *solver)
-    { return HYPRE_ParCSRBiCGSTABCreate(comm, solver);}
-
-  // @}
-  // @{ Internal data
-  
-  //! Pointer to the Epetra_RowMatrix to factorize
-  Teuchos::RefCountPtr<Epetra_RowMatrix> A_;
-  //! This objects copy of the ParameterList
-  Teuchos::ParameterList List_;
-  //! Needed to support Epetra_Operator abstract class
-  bool UseTranspose_;
-  //! A condition estimate for the preconditioner, -1 until Compute()
-  double Condest_;
-  //! If \c true, the preconditioner has been successfully initialized.
-  bool IsInitialized_;
-  //! If \c true, the preconditioner has been successfully computed.
-  bool IsComputed_;
-  //! Label of \c this object.
-  char Label_[160];
-  //! Contains the number of successful calls to Initialize().
-  int NumInitialize_;
-  //! Contains the number of successful call to Compute().
-  int NumCompute_;
-  //! Contains the number of successful call to ApplyInverse().
-  mutable int NumApplyInverse_;
-  //! Contains the time for all successful calls to Initialize().
-  double InitializeTime_;
-  //! Contains the time for all successful calls to Compute().
-  double ComputeTime_;
-  //! Contains the time for all successful calls to ApplyInverse().
-  mutable double ApplyInverseTime_;
-  //! Contains the number of flops for Compute().
-  double ComputeFlops_;
-  //! Contain sthe number of flops for ApplyInverse().
-  mutable double ApplyInverseFlops_;
-  //! Used for timing issues
-  mutable Epetra_Time Time_;
-
-  //! The Hypre matrix created in initialize()
-  mutable HYPRE_IJMatrix HypreA_;
-  //! Pointer to the CSR (same matrix)
-  mutable HYPRE_ParCSRMatrix ParMatrix_;
-  //! The Hypre Vector for input
-  mutable HYPRE_IJVector XHypre_;
-  //! The Hypre Vector for output
-  mutable HYPRE_IJVector YHypre_;
-  mutable HYPRE_ParVector ParX_;
-  mutable HYPRE_ParVector ParY_;
-  mutable hypre_ParVector *XVec_;
-  mutable hypre_ParVector *YVec_;
-  mutable hypre_Vector *XLocal_;
-  mutable hypre_Vector *YLocal_;
-  //! The Hypre Solver if doing a solve
-  mutable HYPRE_Solver Solver_;
-  //! The Hypre Solver if applying preconditioner
-  mutable HYPRE_Solver Preconditioner_;
-  //  The following are pointers to functions to use the solver and preconditioner.
-  int (Ifpack_Hypre::*SolverCreatePtr_)(MPI_Comm, HYPRE_Solver*);
-  int (*SolverDestroyPtr_)(HYPRE_Solver);
-  int (*SolverSetupPtr_)(HYPRE_Solver, HYPRE_ParCSRMatrix, HYPRE_ParVector, HYPRE_ParVector);
-  int (*SolverSolvePtr_)(HYPRE_Solver, HYPRE_ParCSRMatrix, HYPRE_ParVector, HYPRE_ParVector);
-  int (*SolverPrecondPtr_)(HYPRE_Solver, HYPRE_PtrToParSolverFcn, HYPRE_PtrToParSolverFcn, HYPRE_Solver);
-  int (Ifpack_Hypre::*PrecondCreatePtr_)(MPI_Comm, HYPRE_Solver*);
-  int (*PrecondDestroyPtr_)(HYPRE_Solver);
-  int (*PrecondSetupPtr_)(HYPRE_Solver, HYPRE_ParCSRMatrix, HYPRE_ParVector, HYPRE_ParVector);
-  int (*PrecondSolvePtr_)(HYPRE_Solver, HYPRE_ParCSRMatrix, HYPRE_ParVector, HYPRE_ParVector);
-
-  bool *IsSolverSetup_;
-  bool *IsPrecondSetup_;
-  //! Is the system to be solved or apply preconditioner
-  Hypre_Chooser SolveOrPrec_;
-  //! This is a linear map used the way it is in Hypre
-  Teuchos::RefCountPtr<Epetra_Map> MySimpleMap_;
-  //! This is a linear map used the way it is in Hypre
-  Teuchos::RefCountPtr<Epetra_Map> MySimpleColumnMap_;
-  //! Counter of the number of parameters set
-  int NumFunsToCall_;
-  //! Which solver was chosen
-  Hypre_Solver SolverType_;
-  //! Which preconditioner was chosen
-  Hypre_Solver PrecondType_;
-  //! Should the preconditioner be used in the solver
-  bool UsePreconditioner_;
-  //! This contains a list of function pointers that will be called in compute
-  std::vector<Teuchos::RCP<FunctionParameter> > FunsToCall_;
-  //! true if the row map of provided matrix is in form that Hypre likes
-  bool NiceRowMap_;
-};
-
-#endif // HAVE_HYPRE
-#endif /* IFPACK_HYPRE_H */
